
; 64tass Turbo Assembler Macro V1.55.2200 listing file
; 64tass -c -q -L sour16.lst -o sour16.prg -l sour16.lbl sour16.asm
; Sun Jun 07 19:19:00 2020

;Offset	;Hex		;Monitor	;Source

;******  Processing input file: sour16.asm

>0008					Vars:	.fill 	16*2 						; registers in low/high byte pairs
>0028					pctr:	.fill 	2							; address of current routine.
>002a					temp0:	.fill 	2
.1000					Sour16Base:
.1000	4c fc 11	jmp $11fc			jmp 	RunProgram
.1003	ea		nop				nop 								; pad to 4 bytes.
.1004					StartVector:
>1004	00 00 00 00					.word 	0,0
.1008					HighMemory:
>1008	bb 12						.word 	Sour16End

;******  Processing file: sourmisc.asm

=$0a					TestVariable = Vars+2 						; we test on R1
>100a							.align 	16
.1010					BranchZero:
.1010	a5 0a		lda $0a				lda 	TestVariable
.1012	05 0b		ora $0b				ora 	TestVariable+1
.1014	f0 1a		beq $1030			beq 	BranchTrue
.1016	80 0e		bra $1026			bra 	BranchFalse
>1018							.align 	16
.1020					BranchNonZero:
.1020	a5 0a		lda $0a				lda 	TestVariable
.1022	05 0b		ora $0b				ora 	TestVariable+1
.1024	d0 0a		bne $1030			bne 	BranchTrue
.1026					BranchFalse:
.1026	e6 28		inc $28				inc 	pctr
.1028	90 02		bcc $102c			bcc 	BranchFalseNoCarry
.102a	e6 29		inc $29				inc 	pctr+1
.102c					BranchFalseNoCarry:
.102c	4c 16 12	jmp $1216			jmp 	Sour16Next
>102f							.align 	16
.1030					BranchTrue:
.1030	a2 00		ldx #$00			ldx 	#0 							; X is the sign extended offset
.1032	b2 28		lda ($28)			lda 	(pctr) 						; get offset, this is from the offset itself.
.1034	10 01		bpl $1037			bpl 	BTPositive
.1036	ca		dex				dex 								; if -ve make sign extended 255
.1037					BTPositive:
.1037	18		clc				clc 								; add to PCTR
.1038	65 28		adc $28				adc 	pctr
.103a	85 28		sta $28				sta 	pctr
.103c	8a		txa				txa
.103d	65 29		adc $29				adc 	pctr+1
.103f	85 29		sta $29				sta 	pctr+1
.1041	4c 16 12	jmp $1216			jmp 	Sour16Next
>1044							.align 	16
.1050					AssertCmd:
.1050	a5 0a		lda $0a				lda 	TestVariable 				; check R1
.1052	05 0b		ora $0b				ora 	TestVariable+1
.1054	f0 01		beq $1057			beq 	AssertOkay
>1056	ff						.byte 	$FF 						; if non zero break the emulator
.1057					AssertOkay:
.1057	4c 16 12	jmp $1216			jmp 	Sour16Next
>105a							.align 	16
.1060					CallSubroutine:
.1060	a5 29		lda $29				lda 	pctr+1 						; save PCTR Hi
.1062	48		pha				pha
.1063	a5 28		lda $28				lda 	pctr 						; save PCTR Lo
.1065	48		pha				pha
.1066	b2 28		lda ($28)			lda 	(pctr) 						; read new PC low into X
.1068	aa		tax				tax
.1069	a0 01		ldy #$01			ldy 	#1
.106b	b1 28		lda ($28),y			lda 	(pctr),y 					; read new PC high into A
.106d	85 29		sta $29				sta 	pctr+1 						; update address
.106f	86 28		stx $28				stx 	pctr
.1071	4c 16 12	jmp $1216			jmp 	Sour16Next 					; and execute from there.
>1074							.align 	16
.1080					CallMachineCode:
.1080	a9 08		lda #$08			lda 	#Vars 						; address of variables in A
.1082	20 99 10	jsr $1099			jsr 	MachineCodeCaller 			; call the calling code.
.1085	80 09		bra $1090			bra 	ReturnSubroutine 			; and do the return code.
>1087							.align 	16
.1090					ReturnSubroutine:
.1090	68		pla				pla 								; restore PC
.1091	85 28		sta $28				sta 	pctr
.1093	68		pla				pla
.1094	85 29		sta $29				sta 	pctr+1
.1096	4c 0b 12	jmp $120b			jmp 	Sour16NextSkip2 			; return, skipping the code.
.1099					MachineCodeCaller:
.1099	6c 28 00	jmp ($0028)			jmp 	(pctr)
.10f7					MiscellaneousHandler:
.10f7	0a		asl a				asl 	a 							; on entry, 2 x the LSNibble of the word
.10f8	0a		asl a				asl 	a 							; x 4
.10f9	0a		asl a				asl 	a 							; x 16
.10fa	8d fe 10	sta $10fe			sta 	MHAddress+1 				; make the LSB of the jump address
.10fd					MHAddress:
.10fd	4c f7 10	jmp $10f7			jmp 	MiscellaneousHandler

;******  Return to file: sour16.asm


;******  Processing file: sourcore.asm

.1100					Sour16RootCommandSet:
.1100					Command_Miscellaneous:
.1100	80 f5		bra $10f7			bra 	MiscellaneousHandler
>1102							.align 	16
.1110					Command_LoadConstWord:
.1110	b2 28		lda ($28)			lda 	(pctr) 						; copy the first byte in
.1112	95 08		sta $08,x			sta 	Vars,X
.1114	a0 01		ldy #$01			ldy 	#1
.1116	b1 28		lda ($28),y			lda 	(pctr),y 					; copy the second byte in
.1118	95 09		sta $09,x			sta 	Vars+1,X
.111a	4c 0b 12	jmp $120b			jmp 	Sour16NextSkip2 			; return skipping 2.
>111d							.align 	16
.1120					Command_AddRegister:
.1120	18		clc				clc
.1121	b5 08		lda $08,x			lda 	Vars,x
.1123	75 0a		adc $0a,x			adc 	Vars+2,x
.1125	95 08		sta $08,x			sta		Vars,x
.1127	b5 09		lda $09,x			lda 	Vars+1,x
.1129	75 0b		adc $0b,x			adc 	Vars+3,x
.112b	95 09		sta $09,x			sta		Vars+1,x
.112d	4c 16 12	jmp $1216			jmp 	Sour16Next
>1130							.align 	16
.1130					Command_SubRegister:
.1130	38		sec				sec
.1131	b5 08		lda $08,x			lda 	Vars,x
.1133	f5 0a		sbc $0a,x			sbc 	Vars+2,x
.1135	95 08		sta $08,x			sta		Vars,x
.1137	b5 09		lda $09,x			lda 	Vars+1,x
.1139	f5 0b		sbc $0b,x			sbc 	Vars+3,x
.113b	95 09		sta $09,x			sta		Vars+1,x
.113d	4c 16 12	jmp $1216			jmp 	Sour16Next
>1140							.align 	16
.1140					Command_AndRegister:
.1140	b5 08		lda $08,x			lda 	Vars,x
.1142	35 0a		and $0a,x			and 	Vars+2,x
.1144	95 08		sta $08,x			sta		Vars,x
.1146	b5 09		lda $09,x			lda 	Vars+1,x
.1148	35 0b		and $0b,x			and 	Vars+3,x
.114a	95 09		sta $09,x			sta		Vars+1,x
.114c	4c 16 12	jmp $1216			jmp 	Sour16Next
>114f							.align 	16
.1150					Command_OrRegister:
.1150	b5 08		lda $08,x			lda 	Vars,x
.1152	15 0a		ora $0a,x			ora 	Vars+2,x
.1154	95 08		sta $08,x			sta		Vars,x
.1156	b5 09		lda $09,x			lda 	Vars+1,x
.1158	15 0b		ora $0b,x			ora 	Vars+3,x
.115a	95 09		sta $09,x			sta		Vars+1,x
.115c	4c 16 12	jmp $1216			jmp 	Sour16Next
>115f							.align 	16
.1160					Command_XorRegister:
.1160	b5 08		lda $08,x			lda 	Vars,x
.1162	55 0a		eor $0a,x			eor 	Vars+2,x
.1164	95 08		sta $08,x			sta		Vars,x
.1166	b5 09		lda $09,x			lda 	Vars+1,x
.1168	55 0b		eor $0b,x			eor 	Vars+3,x
.116a	95 09		sta $09,x			sta		Vars+1,x
.116c	4c 16 12	jmp $1216			jmp 	Sour16Next
>116f							.align 	16
.1170					Command_StoreByteInd:
.1170	b5 08		lda $08,x			lda 	Vars,x 						; value to write
.1172	92 08		sta ($08)			sta 	(Vars) 						; store indirect via R0.
.1174	4c 16 12	jmp $1216			jmp 	Sour16Next
>1177							.align 	16
.1180					Command_LoadWordInd:
.1180	8e 84 11	stx $1184			stx 	CLWI0+1 					; set to load high byte
.1183					CLWI0:
.1183	a0 01		ldy #$01			ldy 	#1
.1185	b1 00		lda ($00),y			lda 	($00),y 					; read the high byte.
.1187	a8		tay				tay 								; put it in Y temporarily.
.1188	80 08		bra $1192			bra 	CLBIEntrance 				; and do the low code
>118a							.align 	16
.1190					Command_LoadByteInd:
.1190	a0 00		ldy #$00			ldy 	#0 							; zero high byte value.
.1192					CLBIEntrance:
.1192	8e 96 11	stx $1196			stx 	CLBI0+1 					; set to load low byte
.1195					CLBI0:
.1195	b2 00		lda ($00)			lda 	($00) 						; read the low byte.
.1197	95 08		sta $08,x			sta 	Vars,x 						; save it into the variable.
.1199	94 09		sty $09,x			sty 	Vars+1,x
.119b	4c 16 12	jmp $1216			jmp 	Sour16Next
>119e							.align 	16
.11a0					Command_Shift:
.11a0	b5 0a		lda $0a,x			lda 	Vars+2,x 					; the LSB of the second register
.11a2	f0 04		beq $11a8			beq 	Shift_None 					; no shift
.11a4	30 4c		bmi $11f2			bmi 	Shift_Right 				; is a signed value - is shift right logical
.11a6	80 40		bra $11e8			bra 	Shift_Left 					; + is shift left logical.
.11a8					Shift_None:
.11a8	4c 16 12	jmp $1216			jmp 	Sour16Next
>11ab							.align 	16
.11b0					Command_LoadWordDirect:
.11b0	b2 28		lda ($28)			lda 	(pctr) 						; copy address to temp0
.11b2	85 2a		sta $2a				sta 	temp0
.11b4	a0 01		ldy #$01			ldy 	#1
.11b6	b1 28		lda ($28),y			lda 	(pctr),y
.11b8	85 2b		sta $2b				sta 	temp0+1
.11ba	b2 2a		lda ($2a)			lda 	(temp0) 					; read LSB
.11bc	95 08		sta $08,x			sta 	Vars,x
.11be	b1 2a		lda ($2a),y			lda 	(temp0),y 					; read and save MSB
.11c0	95 09		sta $09,x			sta 	Vars+1,x
.11c2	4c 0b 12	jmp $120b			jmp 	Sour16NextSkip2
>11c5							.align 	16
.11d0					Command_StoreIndirectAdvance:
.11d0	b5 08		lda $08,x			lda 	Vars,X 						; get LSB and write out
.11d2	92 08		sta ($08)			sta 	(Vars) 						; to R0
.11d4	b5 09		lda $09,x			lda 	Vars+1,X 					; get MSB
.11d6	a0 01		ldy #$01			ldy 	#1 							; write MSB
.11d8	91 08		sta ($08),y			sta 	(Vars),y
.11da	18		clc				clc
.11db	a5 08		lda $08				lda 	Vars 						; bump by 2
.11dd	69 02		adc #$02			adc 	#2
.11df	85 08		sta $08				sta 	Vars
.11e1	90 02		bcc $11e5			bcc 	CSIANoCarry 				; carry to MSB
.11e3	e6 09		inc $09				inc 	Vars+1
.11e5					CSIANoCarry:
.11e5	4c 0b 12	jmp $120b			jmp 	Sour16NextSkip2
.11e8					Shift_Left:
.11e8	16 08		asl $08,x			asl 	Vars,x
.11ea	36 09		rol $09,x			rol 	Vars+1,x
.11ec	3a		dec a				dec 	a
.11ed	d0 f9		bne $11e8			bne 	Shift_Left
.11ef	4c 16 12	jmp $1216			jmp 	Sour16Next
.11f2					Shift_Right:
.11f2	56 09		lsr $09,x			lsr 	Vars+1,x
.11f4	76 08		ror $08,x			ror 	Vars,x
.11f6	1a		inc a				inc 	a
.11f7	d0 f9		bne $11f2			bne 	Shift_Right
.11f9	4c 16 12	jmp $1216			jmp 	Sour16Next

;******  Return to file: sour16.asm


;******  Processing file: sourrun.asm

.11fc					RunProgram:
.11fc	a2 ff		ldx #$ff			ldx 	#$FF 						; reset stack
.11fe	9a		txs				txs
.11ff	ad 04 10	lda $1004			lda 	StartVector 				; load the initial program counter value.
.1202	85 28		sta $28				sta 	pctr
.1204	ad 05 10	lda $1005			lda 	StartVector+1
.1207	85 29		sta $29				sta 	pctr+1
.1209	80 0b		bra $1216			bra 	Sour16Next
.120b					Sour16NextSkip2:
.120b	18		clc				clc
.120c	a5 28		lda $28				lda 	pctr
.120e	69 02		adc #$02			adc 	#2
.1210	85 28		sta $28				sta 	pctr
.1212	90 02		bcc $1216			bcc 	Sour16Next
.1214	e6 29		inc $29				inc 	pctr+1
.1216					Sour16Next:
.1216	b2 28		lda ($28)			lda 	(pctr) 						; get the opcode
.1218	e6 28		inc $28				inc 	pctr 						; skip the opcode.
.121a	d0 02		bne $121e			bne 	Sour16NoCarry
.121c	e6 29		inc $29				inc 	pctr+1
.121e					Sour16NoCarry:
.121e	aa		tax				tax 								; save in X
.121f	29 f0		and #$f0			and 	#$F0
.1221	8d 2a 12	sta $122a			sta 	S16NJmp+1 					; modify the jump address
.1224	8a		txa				txa 			 					; get the opcode back from X
.1225	29 0f		and #$0f			and 	#15 						; index into the register block.
.1227	0a		asl a				asl 	a 							; (reg# x 2) is also in A.
.1228	aa		tax				tax
.1229					S16NJmp:
.1229	4c 00 11	jmp $1100			jmp 	Sour16RootCommandSet

;******  Return to file: sour16.asm


;******  Processing file: sourextras.asm

=8					CodeOpcode = (CallMachineCode-Sour16Base) >> 4
.122c					Multiply:
>122c	08						.byte 	CodeOpcode
.122d	aa		tax				tax 								; save Base in X.
.122e	18		clc				clc
.122f	75 1e		adc $1e,x			adc 	15*2,X 						; add the base register in RF to it
.1231	75 1e		adc $1e,x			adc	 	15*2,X 						; twice.
.1233	aa		tax				tax
.1234	64 2a		stz $2a				stz 	temp0 						; clear result
.1236	64 2b		stz $2b				stz 	temp0+1
.1238					_MultLoop:
.1238	b5 00		lda $00,x			lda 	0,X 						; check LSB of lower byte
.123a	29 01		and #$01			and 	#1
.123c	f0 0d		beq $124b			beq 	_MultNoAdd
.123e	18		clc				clc 								; add in.
.123f	a5 2a		lda $2a				lda 	temp0
.1241	75 02		adc $02,x			adc 	2,x
.1243	85 2a		sta $2a				sta 	temp0
.1245	a5 2b		lda $2b				lda 	temp0+1
.1247	75 03		adc $03,x			adc 	3,x
.1249	85 2b		sta $2b				sta 	temp0+1
.124b					_MultNoAdd:
.124b	56 01		lsr $01,x			lsr 	1,x 						; shift one right and one left
.124d	76 00		ror $00,x			ror 	0,x
.124f	16 02		asl $02,x			asl 	2,x
.1251	36 03		rol $03,x			rol 	3,x
.1253	b5 00		lda $00,x			lda 	0,x 						; check if done
.1255	15 01		ora $01,x			ora 	1,x
.1257	d0 df		bne $1238			bne 	_MultLoop
.1259	a5 2a		lda $2a				lda 	temp0 						; copy result back.
.125b	95 00		sta $00,x			sta 	0,x
.125d	a5 2b		lda $2b				lda 	temp0+1
.125f	95 01		sta $01,x			sta 	1,x
.1261	60		rts				rts
.1262					Negate:
>1262	08						.byte 	CodeOpcode
.1263	aa		tax				tax 								; save Base in X.
.1264	18		clc				clc
.1265	75 1e		adc $1e,x			adc 	15*2,X 						; add the base register in RF to it
.1267	75 1e		adc $1e,x			adc	 	15*2,X 						; twice.
.1269	aa		tax				tax
.126a	38		sec				sec
.126b	a9 00		lda #$00			lda 	#0
.126d	f5 00		sbc $00,x			sbc 	0,x
.126f	95 00		sta $00,x			sta 	0,x
.1271	a9 00		lda #$00			lda 	#0
.1273	f5 01		sbc $01,x			sbc 	1,x
.1275	95 01		sta $01,x			sta 	1,x
.1277	60		rts				rts
.1278					Divide:
>1278	08						.byte 	CodeOpcode
.1279	38		sec				sec
.127a	80 02		bra $127e			bra 	DivideModulus
.127c					Modulus:
>127c	08						.byte 	CodeOpcode
.127d	18		clc				clc
.127e					DivideModulus:
.127e	08		php				php
.127f	aa		tax				tax 								; save Base in X.
.1280	18		clc				clc
.1281	75 1e		adc $1e,x			adc 	15*2,X 						; add the base register in RF to it
.1283	75 1e		adc $1e,x			adc	 	15*2,X 						; twice.
.1285	aa		tax				tax
.1286	5a		phy				phy 								; Y is the iteration counter
.1287	a0 10		ldy #$10			ldy 	#16
.1289	64 2a		stz $2a				stz 	temp0 						; zero A
.128b	64 2b		stz $2b				stz 	temp0+1
.128d					_DivideLoop:
.128d	16 00		asl $00,x			asl 	0,x 						; shift AQ left
.128f	36 01		rol $01,x			rol 	1,x
.1291	26 2a		rol $2a				rol 	temp0
.1293	26 2b		rol $2b				rol 	temp0+1
.1295	38		sec				sec
.1296	a5 2a		lda $2a				lda 	temp0 						; do A-M calculation
.1298	f5 02		sbc $02,x			sbc 	2,x
.129a	48		pha				pha 								; saved on stack
.129b	a5 2b		lda $2b				lda 	temp0+1
.129d	f5 03		sbc $03,x			sbc 	3,x
.129f	90 09		bcc $12aa			bcc 	_DivideNoAdd
.12a1	85 2b		sta $2b				sta 	temp0+1 					; A-M >= 0
.12a3	68		pla				pla 								; so save the subtraction
.12a4	85 2a		sta $2a				sta 	temp0
.12a6	f6 00		inc $00,x			inc		0,x 						; set the LSB
.12a8	80 01		bra $12ab			bra 	_DivideNext
.12aa					_DivideNoAdd:
.12aa	68		pla				pla 								; throw the interim result
.12ab					_DivideNext:
.12ab	88		dey				dey 								; do the correct number of iterations
.12ac	d0 df		bne $128d			bne 	_DivideLoop
.12ae	7a		ply				ply 								; restore Y
.12af	28		plp				plp 								; return div (CS) mod (CC)
.12b0	b0 08		bcs $12ba			bcs 	_DivideExit
.12b2	a5 2a		lda $2a				lda 	temp0
.12b4	95 00		sta $00,x			sta 	0,x
.12b6	a5 2b		lda $2b				lda 	temp0+1
.12b8	95 01		sta $01,x			sta 	1,x
.12ba					_DivideExit:
.12ba	60		rts				rts

;******  Return to file: sour16.asm

.12bb					Sour16End:

;******  End of listing
