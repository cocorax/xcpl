
; 64tass Turbo Assembler Macro V1.55.2200 listing file
; 64tass -c -q -L sour16.lst -o sour16.prg -l sour16.lbl sour16.asm
; Thu Jun 11 18:57:22 2020

;Offset	;Hex		;Monitor	;Source

;******  Processing input file: sour16.asm

>0008					Vars:	.fill 	16*2 						; registers in low/high byte pairs
>0028					pctr:	.fill 	2							; address of current routine.
>002a					temp0:	.fill 	2
.1000					Sour16Base:
.1000	4c 0c 12	jmp $120c			jmp 	RunProgram
.1003	ea		nop				nop 								; pad to 4 bytes.
.1004					StartVector:
>1004	00 00 00 00					.word 	0,0
.1008					HighMemory:
>1008	77 13						.word 	Sour16End

;******  Processing file: sourmisc.asm

=$0a					TestVariable = Vars+2 						; we test on R1
>100a							.align 	16
.1010					BranchZero:
.1010	a5 0a		lda $0a				lda 	TestVariable
.1012	05 0b		ora $0b				ora 	TestVariable+1
.1014	f0 1a		beq $1030			beq 	BranchTrue
.1016	80 0e		bra $1026			bra 	BranchFalse
>1018							.align 	16
.1020					BranchNonZero:
.1020	a5 0a		lda $0a				lda 	TestVariable
.1022	05 0b		ora $0b				ora 	TestVariable+1
.1024	d0 0a		bne $1030			bne 	BranchTrue
.1026					BranchFalse:
.1026	e6 28		inc $28				inc 	pctr
.1028	90 02		bcc $102c			bcc 	BranchFalseNoCarry
.102a	e6 29		inc $29				inc 	pctr+1
.102c					BranchFalseNoCarry:
.102c	4c 26 12	jmp $1226			jmp 	Sour16Next
>102f							.align 	16
.1030					BranchTrue:
.1030	a2 00		ldx #$00			ldx 	#0 							; X is the sign extended offset
.1032	b2 28		lda ($28)			lda 	(pctr) 						; get offset, this is from the offset itself.
.1034	10 01		bpl $1037			bpl 	BTPositive
.1036	ca		dex				dex 								; if -ve make sign extended 255
.1037					BTPositive:
.1037	18		clc				clc 								; add to PCTR
.1038	65 28		adc $28				adc 	pctr
.103a	85 28		sta $28				sta 	pctr
.103c	8a		txa				txa
.103d	65 29		adc $29				adc 	pctr+1
.103f	85 29		sta $29				sta 	pctr+1
.1041	4c 26 12	jmp $1226			jmp 	Sour16Next
>1044							.align 	16
.1050					AssertCmd:
.1050	a5 0a		lda $0a				lda 	TestVariable 				; check R1
.1052	05 0b		ora $0b				ora 	TestVariable+1
.1054	f0 01		beq $1057			beq 	AssertOkay
>1056	ff						.byte 	$FF 						; if non zero break the emulator
.1057					AssertOkay:
.1057	4c 26 12	jmp $1226			jmp 	Sour16Next
>105a							.align 	16
.1060					CallSubroutine:
.1060	a5 29		lda $29				lda 	pctr+1 						; save PCTR Hi
.1062	48		pha				pha
.1063	a5 28		lda $28				lda 	pctr 						; save PCTR Lo
.1065	48		pha				pha
.1066	b2 28		lda ($28)			lda 	(pctr) 						; read new PC low into X
.1068	aa		tax				tax
.1069	a0 01		ldy #$01			ldy 	#1
.106b	b1 28		lda ($28),y			lda 	(pctr),y 					; read new PC high into A
.106d	85 29		sta $29				sta 	pctr+1 						; update address
.106f	86 28		stx $28				stx 	pctr
.1071	4c 26 12	jmp $1226			jmp 	Sour16Next 					; and execute from there.
>1074							.align 	16
.1080					ReturnSubroutine:
.1080	68		pla				pla 								; restore PC
.1081	85 28		sta $28				sta 	pctr
.1083	68		pla				pla
.1084	85 29		sta $29				sta 	pctr+1
.1086	4c 1b 12	jmp $121b			jmp 	Sour16NextSkip2 			; return, skipping the code.
.1089					MachineCodeCaller:
.1089	6c 28 00	jmp ($0028)			jmp 	(pctr)
.10f0					CallMachineCode:
.10f0	a9 08		lda #$08			lda 	#Vars 						; address of variables in A
.10f2	20 89 10	jsr $1089			jsr 	MachineCodeCaller 			; call the calling code.
.10f5	80 89		bra $1080			bra 	ReturnSubroutine 			; and do the return code.
.10f7					MiscellaneousHandler:
.10f7	0a		asl a				asl 	a 							; on entry, 2 x the LSNibble of the word
.10f8	0a		asl a				asl 	a 							; x 4
.10f9	0a		asl a				asl 	a 							; x 16
.10fa	8d fe 10	sta $10fe			sta 	MHAddress+1 				; make the LSB of the jump address
.10fd					MHAddress:
.10fd	4c f7 10	jmp $10f7			jmp 	MiscellaneousHandler

;******  Return to file: sour16.asm


;******  Processing file: sourcore.asm

.1100					Sour16RootCommandSet:
.1100					Command_Miscellaneous:
.1100	80 f5		bra $10f7			bra 	MiscellaneousHandler
>1102							.align 	16
.1110					Command_LoadConstWord:
.1110	b2 28		lda ($28)			lda 	(pctr) 						; copy the first byte in
.1112	95 08		sta $08,x			sta 	Vars,X
.1114	a0 01		ldy #$01			ldy 	#1
.1116	b1 28		lda ($28),y			lda 	(pctr),y 					; copy the second byte in
.1118	95 09		sta $09,x			sta 	Vars+1,X
.111a	4c 1b 12	jmp $121b			jmp 	Sour16NextSkip2 			; return skipping 2.
>111d							.align 	16
.1120					Command_LoadConstByte:
.1120	b2 28		lda ($28)			lda 	(pctr) 						; copy the byte in
.1122	95 08		sta $08,x			sta 	Vars,X
.1124	74 09		stz $09,x			stz 	Vars+1,X 					; zero the MSB.
.1126	e6 28		inc $28				inc 	pctr 						; skip opcode
.1128	90 02		bcc $112c			bcc 	_CLCBNoCarry
.112a	e6 29		inc $29				inc 	pctr+1
.112c					_CLCBNoCarry:
.112c	4c 26 12	jmp $1226			jmp 	Sour16Next 					; return
>112f							.align 	16
.1130					Command_AddRegister:
.1130	18		clc				clc
.1131	b5 08		lda $08,x			lda 	Vars,x
.1133	75 0a		adc $0a,x			adc 	Vars+2,x
.1135	95 08		sta $08,x			sta		Vars,x
.1137	b5 09		lda $09,x			lda 	Vars+1,x
.1139	75 0b		adc $0b,x			adc 	Vars+3,x
.113b	95 09		sta $09,x			sta		Vars+1,x
.113d	4c 26 12	jmp $1226			jmp 	Sour16Next
>1140							.align 	16
.1140					Command_SubRegister:
.1140	38		sec				sec
.1141	b5 08		lda $08,x			lda 	Vars,x
.1143	f5 0a		sbc $0a,x			sbc 	Vars+2,x
.1145	95 08		sta $08,x			sta		Vars,x
.1147	b5 09		lda $09,x			lda 	Vars+1,x
.1149	f5 0b		sbc $0b,x			sbc 	Vars+3,x
.114b	95 09		sta $09,x			sta		Vars+1,x
.114d	4c 26 12	jmp $1226			jmp 	Sour16Next
>1150							.align 	16
.1150					Command_AndRegister:
.1150	b5 08		lda $08,x			lda 	Vars,x
.1152	35 0a		and $0a,x			and 	Vars+2,x
.1154	95 08		sta $08,x			sta		Vars,x
.1156	b5 09		lda $09,x			lda 	Vars+1,x
.1158	35 0b		and $0b,x			and 	Vars+3,x
.115a	95 09		sta $09,x			sta		Vars+1,x
.115c	4c 26 12	jmp $1226			jmp 	Sour16Next
>115f							.align 	16
.1160					Command_OrRegister:
.1160	b5 08		lda $08,x			lda 	Vars,x
.1162	15 0a		ora $0a,x			ora 	Vars+2,x
.1164	95 08		sta $08,x			sta		Vars,x
.1166	b5 09		lda $09,x			lda 	Vars+1,x
.1168	15 0b		ora $0b,x			ora 	Vars+3,x
.116a	95 09		sta $09,x			sta		Vars+1,x
.116c	4c 26 12	jmp $1226			jmp 	Sour16Next
>116f							.align 	16
.1170					Command_XorRegister:
.1170	b5 08		lda $08,x			lda 	Vars,x
.1172	55 0a		eor $0a,x			eor 	Vars+2,x
.1174	95 08		sta $08,x			sta		Vars,x
.1176	b5 09		lda $09,x			lda 	Vars+1,x
.1178	55 0b		eor $0b,x			eor 	Vars+3,x
.117a	95 09		sta $09,x			sta		Vars+1,x
.117c	4c 26 12	jmp $1226			jmp 	Sour16Next
>117f							.align 	16
.1180					Command_StoreByteInd:
.1180	b5 08		lda $08,x			lda 	Vars,x 						; value to write
.1182	92 08		sta ($08)			sta 	(Vars) 						; store indirect via R0.
.1184	4c 26 12	jmp $1226			jmp 	Sour16Next
.1187					CompleteLWI:
.1187	a0 01		ldy #$01			ldy 	#1 							; read the MSB and write out.
.1189	b1 2a		lda ($2a),y			lda 	(temp0),y
.118b	95 09		sta $09,x			sta 	Vars+1,x
.118d	4c 26 12	jmp $1226			jmp 	Sour16Next
>1190							.align 	16
.1190					Command_LoadWordInd:
.1190	b5 08		lda $08,x			lda 	Vars,x 						; copy Vars,X to Temp0
.1192	85 2a		sta $2a				sta 	temp0
.1194	b5 09		lda $09,x			lda 	Vars+1,x
.1196	85 2b		sta $2b				sta 	temp0+1
.1198	b2 2a		lda ($2a)			lda 	(temp0) 					; read the low byte indirectly
.119a	95 08		sta $08,x			sta 	Vars,x 						; save it into the variable.
.119c	80 e9		bra $1187			bra 	CompleteLWI
>119e							.align 	16
.11a0					Command_LoadByteInd:
.11a0	a1 08		lda ($08,x)			lda 	(Vars,X) 					; read the byte indirectly
.11a2	95 08		sta $08,x			sta 	Vars,x 						; save it into the variable.
.11a4	74 09		stz $09,x			stz 	Vars+1,x 					; clear the MSB.
.11a6	4c 26 12	jmp $1226			jmp 	Sour16Next
>11a9							.align 	16
.11b0					Command_Shift:
.11b0	b5 0a		lda $0a,x			lda 	Vars+2,x 					; the LSB of the second register
.11b2	f0 04		beq $11b8			beq 	Shift_None 					; no shift
.11b4	30 4c		bmi $1202			bmi 	Shift_Right 				; is a signed value - is shift right logical
.11b6	80 40		bra $11f8			bra 	Shift_Left 					; + is shift left logical.
.11b8					Shift_None:
.11b8	4c 26 12	jmp $1226			jmp 	Sour16Next
>11bb							.align 	16
.11c0					Command_LoadWordDirect:
.11c0	b2 28		lda ($28)			lda 	(pctr) 						; copy address to temp0
.11c2	85 2a		sta $2a				sta 	temp0
.11c4	a0 01		ldy #$01			ldy 	#1
.11c6	b1 28		lda ($28),y			lda 	(pctr),y
.11c8	85 2b		sta $2b				sta 	temp0+1
.11ca	b2 2a		lda ($2a)			lda 	(temp0) 					; read LSB
.11cc	95 08		sta $08,x			sta 	Vars,x
.11ce	b1 2a		lda ($2a),y			lda 	(temp0),y 					; read and save MSB
.11d0	95 09		sta $09,x			sta 	Vars+1,x
.11d2	4c 1b 12	jmp $121b			jmp 	Sour16NextSkip2
>11d5							.align 	16
.11e0					Command_StoreIndirectAdvance:
.11e0	b5 08		lda $08,x			lda 	Vars,X 						; get LSB and write out
.11e2	92 08		sta ($08)			sta 	(Vars) 						; to R0
.11e4	b5 09		lda $09,x			lda 	Vars+1,X 					; get MSB
.11e6	a0 01		ldy #$01			ldy 	#1 							; write MSB
.11e8	91 08		sta ($08),y			sta 	(Vars),y
.11ea	18		clc				clc
.11eb	a5 08		lda $08				lda 	Vars 						; bump by 2
.11ed	69 02		adc #$02			adc 	#2
.11ef	85 08		sta $08				sta 	Vars
.11f1	90 02		bcc $11f5			bcc 	CSIANoCarry 				; carry to MSB
.11f3	e6 09		inc $09				inc 	Vars+1
.11f5					CSIANoCarry:
.11f5	4c 26 12	jmp $1226			jmp 	Sour16Next
.11f8					Shift_Left:
.11f8	16 08		asl $08,x			asl 	Vars,x
.11fa	36 09		rol $09,x			rol 	Vars+1,x
.11fc	3a		dec a				dec 	a
.11fd	d0 f9		bne $11f8			bne 	Shift_Left
.11ff	4c 26 12	jmp $1226			jmp 	Sour16Next
.1202					Shift_Right:
.1202	56 09		lsr $09,x			lsr 	Vars+1,x
.1204	76 08		ror $08,x			ror 	Vars,x
.1206	1a		inc a				inc 	a
.1207	d0 f9		bne $1202			bne 	Shift_Right
.1209	4c 26 12	jmp $1226			jmp 	Sour16Next

;******  Return to file: sour16.asm


;******  Processing file: sourrun.asm

.120c					RunProgram:
.120c	a2 ff		ldx #$ff			ldx 	#$FF 						; reset stack
.120e	9a		txs				txs
.120f	ad 04 10	lda $1004			lda 	StartVector 				; load the initial program counter value.
.1212	85 28		sta $28				sta 	pctr
.1214	ad 05 10	lda $1005			lda 	StartVector+1
.1217	85 29		sta $29				sta 	pctr+1
.1219	80 0b		bra $1226			bra 	Sour16Next
.121b					Sour16NextSkip2:
.121b	18		clc				clc
.121c	a5 28		lda $28				lda 	pctr
.121e	69 02		adc #$02			adc 	#2
.1220	85 28		sta $28				sta 	pctr
.1222	90 02		bcc $1226			bcc 	Sour16Next
.1224	e6 29		inc $29				inc 	pctr+1
.1226					Sour16Next:
.1226	b2 28		lda ($28)			lda 	(pctr) 						; get the opcode
.1228	e6 28		inc $28				inc 	pctr 						; skip the opcode.
.122a	d0 02		bne $122e			bne 	Sour16NoCarry
.122c	e6 29		inc $29				inc 	pctr+1
.122e					Sour16NoCarry:
.122e	aa		tax				tax 								; save in X
.122f	29 f0		and #$f0			and 	#$F0
.1231	8d 3a 12	sta $123a			sta 	S16NJmp+1 					; modify the jump address
.1234	8a		txa				txa 			 					; get the opcode back from X
.1235	29 0f		and #$0f			and 	#15 						; index into the register block.
.1237	0a		asl a				asl 	a 							; (reg# x 2) is also in A.
.1238	aa		tax				tax
.1239					S16NJmp:
.1239	4c 00 11	jmp $1100			jmp 	Sour16RootCommandSet

;******  Return to file: sour16.asm


;******  Processing file: sourmath.asm

=15					CodeOpcode = (CallMachineCode-Sour16Base) >> 4
.123c					Multiply:
>123c	0f						.byte 	CodeOpcode
.123d	aa		tax				tax 								; save Base in X.
.123e	18		clc				clc
.123f	75 1e		adc $1e,x			adc 	15*2,X 						; add the base register in RF to it
.1241	75 1e		adc $1e,x			adc	 	15*2,X 						; twice.
.1243	aa		tax				tax
.1244	64 2a		stz $2a				stz 	temp0 						; clear result
.1246	64 2b		stz $2b				stz 	temp0+1
.1248					_MultLoop:
.1248	b5 00		lda $00,x			lda 	0,X 						; check LSB of lower byte
.124a	29 01		and #$01			and 	#1
.124c	f0 0d		beq $125b			beq 	_MultNoAdd
.124e	18		clc				clc 								; add in.
.124f	a5 2a		lda $2a				lda 	temp0
.1251	75 02		adc $02,x			adc 	2,x
.1253	85 2a		sta $2a				sta 	temp0
.1255	a5 2b		lda $2b				lda 	temp0+1
.1257	75 03		adc $03,x			adc 	3,x
.1259	85 2b		sta $2b				sta 	temp0+1
.125b					_MultNoAdd:
.125b	56 01		lsr $01,x			lsr 	1,x 						; shift one right and one left
.125d	76 00		ror $00,x			ror 	0,x
.125f	16 02		asl $02,x			asl 	2,x
.1261	36 03		rol $03,x			rol 	3,x
.1263	b5 00		lda $00,x			lda 	0,x 						; check if done
.1265	15 01		ora $01,x			ora 	1,x
.1267	d0 df		bne $1248			bne 	_MultLoop
.1269	a5 2a		lda $2a				lda 	temp0 						; copy result back.
.126b	95 00		sta $00,x			sta 	0,x
.126d	a5 2b		lda $2b				lda 	temp0+1
.126f	95 01		sta $01,x			sta 	1,x
.1271	60		rts				rts
.1272					Negate:
>1272	0f						.byte 	CodeOpcode
.1273	aa		tax				tax 								; save Base in X.
.1274	18		clc				clc
.1275	75 1e		adc $1e,x			adc 	15*2,X 						; add the base register in RF to it
.1277	75 1e		adc $1e,x			adc	 	15*2,X 						; twice.
.1279	aa		tax				tax
.127a	38		sec				sec
.127b	a9 00		lda #$00			lda 	#0
.127d	f5 00		sbc $00,x			sbc 	0,x
.127f	95 00		sta $00,x			sta 	0,x
.1281	a9 00		lda #$00			lda 	#0
.1283	f5 01		sbc $01,x			sbc 	1,x
.1285	95 01		sta $01,x			sta 	1,x
.1287	60		rts				rts
.1288					Divide:
>1288	0f						.byte 	CodeOpcode
.1289	38		sec				sec
.128a	80 02		bra $128e			bra 	DivideModulus
.128c					Modulus:
>128c	0f						.byte 	CodeOpcode
.128d	18		clc				clc
.128e					DivideModulus:
.128e	08		php				php
.128f	aa		tax				tax 								; save Base in X.
.1290	18		clc				clc
.1291	75 1e		adc $1e,x			adc 	15*2,X 						; add the base register in RF to it
.1293	75 1e		adc $1e,x			adc	 	15*2,X 						; twice.
.1295	aa		tax				tax
.1296	5a		phy				phy 								; Y is the iteration counter
.1297	a0 10		ldy #$10			ldy 	#16
.1299	64 2a		stz $2a				stz 	temp0 						; zero A
.129b	64 2b		stz $2b				stz 	temp0+1
.129d					_DivideLoop:
.129d	16 00		asl $00,x			asl 	0,x 						; shift AQ left
.129f	36 01		rol $01,x			rol 	1,x
.12a1	26 2a		rol $2a				rol 	temp0
.12a3	26 2b		rol $2b				rol 	temp0+1
.12a5	38		sec				sec
.12a6	a5 2a		lda $2a				lda 	temp0 						; do A-M calculation
.12a8	f5 02		sbc $02,x			sbc 	2,x
.12aa	48		pha				pha 								; saved on stack
.12ab	a5 2b		lda $2b				lda 	temp0+1
.12ad	f5 03		sbc $03,x			sbc 	3,x
.12af	90 09		bcc $12ba			bcc 	_DivideNoAdd
.12b1	85 2b		sta $2b				sta 	temp0+1 					; A-M >= 0
.12b3	68		pla				pla 								; so save the subtraction
.12b4	85 2a		sta $2a				sta 	temp0
.12b6	f6 00		inc $00,x			inc		0,x 						; set the LSB
.12b8	80 01		bra $12bb			bra 	_DivideNext
.12ba					_DivideNoAdd:
.12ba	68		pla				pla 								; throw the interim result
.12bb					_DivideNext:
.12bb	88		dey				dey 								; do the correct number of iterations
.12bc	d0 df		bne $129d			bne 	_DivideLoop
.12be	7a		ply				ply 								; restore Y
.12bf	28		plp				plp 								; return div (CS) mod (CC)
.12c0	b0 08		bcs $12ca			bcs 	_DivideExit
.12c2	a5 2a		lda $2a				lda 	temp0
.12c4	95 00		sta $00,x			sta 	0,x
.12c6	a5 2b		lda $2b				lda 	temp0+1
.12c8	95 01		sta $01,x			sta 	1,x
.12ca					_DivideExit:
.12ca	60		rts				rts
.12cb					IncrementLoad:
>12cb	0f						.byte 	CodeOpcode
.12cc	a9 01		lda #$01			lda 	#1 							; XA is value to add
.12ce	a2 00		ldx #$00			ldx 	#0
.12d0	80 04		bra $12d6			bra 	ModLoad
.12d2					DecrementLoad:
>12d2	0f						.byte 	CodeOpcode
.12d3	a9 ff		lda #$ff			lda 	#$FF
.12d5	aa		tax				tax
.12d6					ModLoad:
.12d6	18		clc				clc 								; bump the value
.12d7	72 0a		adc ($0a)			adc 	(Vars+2)
.12d9	92 0a		sta ($0a)			sta 	(Vars+2)
.12db	48		pha				pha
.12dc	8a		txa				txa
.12dd	a0 01		ldy #$01			ldy 	#1
.12df	71 0a		adc ($0a),y			adc 	(Vars+2),y
.12e1	91 0a		sta ($0a),y			sta 	(Vars+2),y
.12e3	85 0b		sta $0b				sta 	Vars+3						; save into R1
.12e5	68		pla				pla
.12e6	85 0a		sta $0a				sta 	Vars+2
.12e8	60		rts				rts

;******  Return to file: sour16.asm


;******  Processing file: sourcompare.asm

.12e9					Equals:
>12e9	0f						.byte 	CodeOpcode
.12ea	18		clc				clc 								; clc keeps the result, sec inverts it
.12eb	80 02		bra $12ef			bra 	EqualMain
.12ed					NotEqual:
>12ed	0f						.byte 	CodeOpcode
.12ee	38		sec				sec
.12ef					EqualMain:
.12ef	08		php				php 								; save flip bit
.12f0	aa		tax				tax 								; save Base in X.
.12f1	18		clc				clc
.12f2	75 1e		adc $1e,x			adc 	15*2,X 						; add the base register in RF to it
.12f4	75 1e		adc $1e,x			adc	 	15*2,X 						; twice.
.12f6	aa		tax				tax
.12f7	b5 00		lda $00,x			lda		0,X 						; check if equals.
.12f9	d5 02		cmp $02,x			cmp 	2,X
.12fb	d0 12		bne $130f			bne 	CondFail
.12fd	b5 01		lda $01,x			lda 	1,x
.12ff	d5 03		cmp $03,x			cmp 	3,x
.1301	d0 0c		bne $130f			bne 	CondFail
.1303					CondSucceed:
.1303	a9 ff		lda #$ff			lda 	#$FF 						; return true.
.1305	28		plp				plp
.1306	90 02		bcc $130a			bcc 	CondSaveExit
.1308	a9 00		lda #$00			lda 	#$00						; if flip return 00
.130a					CondSaveExit:
.130a	95 00		sta $00,x			sta 	0,x 						; write out 0 or -1
.130c	95 01		sta $01,x			sta 	1,x
.130e	60		rts				rts
.130f					CondFail:
.130f	a9 00		lda #$00			lda 	#$00 						; return false.
.1311	28		plp				plp
.1312	90 f6		bcc $130a			bcc 	CondSaveExit
.1314	a9 ff		lda #$ff			lda 	#$FF
.1316	80 f2		bra $130a			bra 	CondSaveExit
.1318					GreaterEquals:
>1318	0f						.byte 	CodeOpcode
.1319	18		clc				clc 								; clc keeps the result, sec inverts it
.131a	80 02		bra $131e			bra 	GEqualMain
.131c					Less:
>131c	0f						.byte 	CodeOpcode
.131d	38		sec				sec
.131e					GEqualMain:
.131e	08		php				php 								; save flip bit
.131f	aa		tax				tax 								; save Base in X.
.1320	18		clc				clc
.1321	75 1e		adc $1e,x			adc 	15*2,X 						; add the base register in RF to it
.1323	75 1e		adc $1e,x			adc	 	15*2,X 						; twice.
.1325	aa		tax				tax
.1326	38		sec				sec 								; do the comparison
.1327	b5 00		lda $00,x			lda 	0,X
.1329	f5 02		sbc $02,x			sbc 	2,x
.132b	b5 01		lda $01,x			lda 	1,x
.132d	f5 03		sbc $03,x			sbc		3,x
.132f	b0 d2		bcs $1303			bcs 	CondSucceed 				; >= true
.1331	80 dc		bra $130f			bra 	CondFail 					; < false
.1333					Greater:
>1333	0f						.byte 	CodeOpcode
.1334	18		clc				clc 								; clc keeps the result, sec inverts it
.1335	80 02		bra $1339			bra 	GMain
.1337					LessEqual:
>1337	0f						.byte 	CodeOpcode
.1338	38		sec				sec
.1339					GMain:
.1339	08		php				php 								; save flip bit
.133a	aa		tax				tax 								; save Base in X.
.133b	18		clc				clc
.133c	75 1e		adc $1e,x			adc 	15*2,X 						; add the base register in RF to it
.133e	75 1e		adc $1e,x			adc	 	15*2,X 						; twice.
.1340	aa		tax				tax
.1341	38		sec				sec 								; do the comparison
.1342	b5 02		lda $02,x			lda 	2,X
.1344	f5 00		sbc $00,x			sbc 	0,x
.1346	b5 03		lda $03,x			lda 	3,x
.1348	f5 01		sbc $01,x			sbc		1,x
.134a	90 b7		bcc $1303			bcc 	CondSucceed 				; >= true
.134c	80 c1		bra $130f			bra 	CondFail 					; < false

;******  Return to file: sour16.asm


;******  Processing file: sourdebug.asm

.134e					DebugPrintChar:
>134e	0f						.byte 	CodeOpcode
.134f	a5 0a		lda $0a				lda 	Vars+2 						; get R1
.1351					OSPrintChar:
.1351	4c d2 ff	jmp $ffd2			jmp 	$FFD2 						; call output routine
.1354					DebugPrintHex:
>1354	0f						.byte 	CodeOpcode
.1355	a9 20		lda #$20			lda 	#' '
.1357	20 51 13	jsr $1351			jsr 	OSPrintChar
.135a	a5 0b		lda $0b				lda 	Vars+3
.135c	20 61 13	jsr $1361			jsr 	_DPH1
.135f	a5 0a		lda $0a				lda 	Vars+2
.1361					_DPH1:
.1361	48		pha				pha
.1362	4a		lsr a				lsr 	a
.1363	4a		lsr a				lsr 	a
.1364	4a		lsr a				lsr 	a
.1365	4a		lsr a				lsr 	a
.1366	20 6a 13	jsr $136a			jsr 	_DPH2
.1369	68		pla				pla
.136a					_DPH2:
.136a	29 0f		and #$0f			and 	#$0F
.136c	c9 0a		cmp #$0a			cmp 	#$0A
.136e	90 02		bcc $1372			bcc 	_DPH3
.1370	69 06		adc #$06			adc 	#6
.1372					_DPH3:
.1372	69 30		adc #$30			adc 	#48
.1374	4c 51 13	jmp $1351			jmp 	OSPrintChar

;******  Return to file: sour16.asm

.1377					Sour16End:

;******  End of listing
